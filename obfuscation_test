@name Random Maze Generator by PCL ('HMM)
@persist Il:table I1:table I1l I11:string I1ll I1l1 I11l I111
@persist I1lll I1ll1 I1l1l I1l11 I11ll:entity I11l1
    if(first()) { I11l =17   I1l11 = 10   I11l1 = 1000    I1l = 1 I1 = table() I111 = 140         function void holo_line(I111l:number,I1111:vector,I1llll:vector) { I1lll1 = (I1111+I1llll)/2 holoCreate(I111l) holoScaleUnits(I111l, vec(I1111:distance(I1llll)+5,5,7.5)) holoPos(I111l,(I1111+I1llll)/2) holoColor(I111l,vec(100,255,100)) local I1ll1l = (I1111-I1llll):normalized() holoAng(I111l,I1ll1l:toAngle()) } function array array:remove_vector2(I1ll11:vector2) { for(I1l1ll=1,This:count()) { if(This[I1l1ll,vector2]==I1ll11) { This:remove(I1l1ll) return This } } } function angle wall_angle(I1ll11:vector2) {     local I1l1l1 = table() if(I1ll11==vec2(0,1)) { return ang(0,0,0) } elseif(I1ll11==vec2(0,-1)) { return ang(0,0,0) } elseif(I1ll11==vec2(1,0)) { return ang(0,90,0) } elseif(I1ll11==vec2(-1,0)) { return ang(0,90,0) } return ang(0,22,130) } function vector2 inverse_vec2(I1ll11:vector2) { local I1l11l = 0 local I1l111 = 0 if(I1ll11:x() == 0 ) { I1l11l = 0 } else { I1l11l = 0-I1ll11:x() } if(I1ll11:y() == 0) { I1l111 = 0 } else { I1l111 = 0-I1ll11:y() } return vec2(I1l11l,I1l111) } function table create_cell(I1l11l,I1l111) { local I11lll = table()   I11lll["walls",array] = array(vec2(0,1),vec2(0,-1),vec2(1,0),vec2(-1,0)) I11lll["visited",number] = 0 I11lll["pos",vector2] = vec2(I1l11l,I1l111) holoCreate(I1l) holoPos(I1l,vec(I1l11l*I111,I1l111*I111,10)+entity():pos()) holoScaleUnits(I1l,vec(I111-0.3,I111-0.3,4))   I1l++ return I11lll } function vector2 create_path(I11ll1:number, I1l11l,I1l111) { I1[I11ll1*(I1l111-1)+I1l11l,table]["visited",number] = 1 I11l1l = array(vec2(0,1),vec2(0,-1),vec2(1,0),vec2(-1,0)) local I11l11 = array(2,1,4,3) while(I11l1l:count()>0) { local I111ll = randint(1,I11l1l:count()) local I111l1 = I11l1l:removeVector2(I111ll) local I1111l = vec2(I1l11l,I1l111)+I111l1   if(I1111l:x()>0&I1111l:y()>0&I1111l:x()<I11ll1+1&I1111l:y()<I11ll1+1) { if(I1[I11ll1*(I1111l:y()-1)+I1111l:x(),table]["visited",number] == 0) { I1[I11ll1*(I1l111-1)+I1l11l,table]["walls",array]:remove_vector2(I111l1) I1[I11ll1*(I1111l:y()-1)+I1111l:x(),table]["walls",array]:remove_vector2(inverse_vec2(I111l1)) I1[I11ll1*(I1111l:y()-1)+I1111l:x(),table]["visited",number] = 1 holoColor(I11ll1*(I1111l:y()-1)+I1111l:x(),vec(140,140,255)) holo_line(I1l,vec(I1l11l*I111,I1l111*I111,9)+entity():pos(),vec(I1111l:x()*I111,I1111l:y()*I111,9)+entity():pos()) I1l++ return I1111l } } } return vec2(-1,-1)  } function void create_wall(I1l11l:number,I1l111:number,I111l1:vector2) { if(I1l111<=I11l & I1l11l<=I11l) { if(I1[I11l*(I1l111+I111l1:y()-1)+I1l11l+I111l1:x(),table]["visited",number]!=2 | I1l111+I111l1:y()>I11l | I1l11l+I111l1:x()>I11l | I1l111+I111l1:y()<1 | I1l11l+I111l1:x()<1) { if(!propCanCreate()) { print("interval to fast to spawn props Increase PSpawn_interval and replace e2") } I11111 = propSpawn("models/hunter/plates/plate3x16.mdl",vec(I1l11l*I111,I1l111*I111,100)+entity():pos()+vec(I111l1:x(),I111l1:y(),0)*I111/2+vec(0,0,175),wall_angle(I111l1)+ang(0,0,90),1) I11111:setMaterial("models/props_canal/metalwall005b") } } } I11 = "create_cells" I1 = table() I1ll = 1 I1l1 = 1 } interval(I1l11) if(I11=="create_path") { while(perf()) { local I11lll = Il[Il:count(),table] holoColor(I11l*(I11lll["pos",vector2]:y()-1)+I11lll["pos",vector2]:x(),vec(140,140,255)) local I1lllll = create_path(I11l,I11lll["pos",vector2]:x(),I11lll["pos",vector2]:y()) if(Il:count()<1) { I11 = "create_walls" I1lll = 1 I1ll1 = 1 I1l11 = I11l1     } if(I1lllll!=vec2(-1,-1)) { if(!holoCanCreate())  { print("holo cant create") } holoColor(I11l*(I1lllll:y()-1)+I1lllll:x(),vec(255,100,100)) Il:pushTable(I1[I11l*(I1lllll:y()-1)+I1lllll:x(),table]) break } else { local I11lll = Il[Il:count(),table] holoColor(I11l*(I11lll["pos",vector2]:y()-1)+I11lll["pos",vector2]:x(),vec(140,140,255)) Il:pop() local I11lll = Il[Il:count(),table] holoColor(I11l*(I11lll["pos",vector2]:y()-1)+I11lll["pos",vector2]:x(),vec(255,100,100)) break } } } elseif(I11=="create_cells") { while(perf()) { if(I1l1<=I11l) { if(I1ll<=I11l) { I1:pushTable(create_cell(I1ll,I1l1)) I1ll++ } else { I1ll=1 I1l1++ } } else { I11="create_path" Il = table() Il:pushTable(I1[1,table]) } } } elseif(I11=="create_walls") { while(perf()) { if(I1ll1<=I11l) { if(I1lll<=I11l) { while(I1[I11l*(I1ll1-1)+I1lll,table]["walls",array]:count()>0) { I1llll1 = I1[I11l*(I1ll1-1)+I1lll,table]["walls",array]:popVector2()   I1l++ create_wall(I1lll,I1ll1,I1llll1) } I1[I11l*(I1ll1-1)+I1lll,table]["visited",number] = 2 I1lll++ break } else { I1lll=1 I1ll1++ break } } else { holoDeleteAll() I11 = "" } } } 
