@persist GT_Task:string InputLengthsFull:array  GT_Output:table GT_SubTask
@persist GT_Inc  GT_Code GT_Bits GT_Max_code GT_Max_bits
@persist B1_count:table Next_code:table
@persist OutData:table OutLookupTree:table
if(first()) {
    
    runOnTick(1)
    GT_Task = "wait"
    function void array:generateTreeLookupInto(T:table) {
        
        T["error", string] = ""
        T["done", number] = 0
        T["data", table] = table()    
        OutData = T
        OutLookupTree = table()
        B1_count = table()
        Next_code = table()
        GT_Inc = 1
        GT_SubTask = 0
        GT_Task = "gen_tree"
        InputLengthsFull = This
    }
    
} elseif(tickClk() & GT_Task == "gen_tree") {

 switch(GT_SubTask) {
        
    case 0,
        while(perf(80)) {
            local N =  InputLengthsFull[GT_Inc, number]
            if(N >=1) {
               B1_count[N, number] = B1_count[N, number] + 1
            }
            if(N > GT_Max_bits) { GT_Max_bits = N }
            if(GT_Inc>=InputLengthsFull:count()) {
                GT_Inc = 1
                GT_SubTask++ 
                
                
                GT_Code = 0
                GT_Bits = 1
                GT_Max_code = InputLengthsFull:count()  
                
                break
            }
            GT_Inc++
        }
    
    
    break   
    case 1,
        
        while(perf(80)) {
            if(GT_Bits<=GT_Max_bits)
            {
                GT_Code = (GT_Code + B1_count[GT_Bits-1, number]) << 1
                Next_code[GT_Bits, number] = GT_Code
                GT_Bits++
            } else {
                GT_SubTask++
                GT_Inc = 0
                break
            
            }
               
            
        }
    break
    case 2,
        while(perf(80)) {
 
            local Len = InputLengthsFull[GT_Inc, number]
            if(Len != 0 ) {
                if(!OutLookupTree:exists(Len)) {
                    OutLookupTree[Len, table] = table()   
                }
                OutLookupTree[Len, table][Next_code[Len, number], number] = GT_Inc-1 
                Next_code[Len, number] = Next_code[Len, number] +1
            }
            
            if(GT_Inc>=GT_Max_code) {
                GT_SubTask++
                GT_Inc = 0
                GT_Task = "wait"
                timer("gt_done",1)
                break    
            }
            
                   
            GT_Inc++    
            
        }
    
    
    break
    
    }

} elseif(clk("gt_done")) {
    OutData["data", table] = OutLookupTree
    OutData["done", number]  = 1


}
       
